
"""This module contains a Tentusscher_2004_mcell cardiac cell model

The module was autogenerated from a gotran ode file
"""
from __future__ import division
from collections import OrderedDict
import ufl

from cbcbeat.dolfinimport import *
from cbcbeat.cellmodels import CardiacCellModel

class Tentusscher_2004_mcell(CardiacCellModel):
    def __init__(self, params=None, init_conditions=None):
        """
        Create cardiac cell model

        *Arguments*
         params (dict, :py:class:`dolfin.Mesh`, optional)
           optional model parameters
         init_conditions (dict, :py:class:`dolfin.Mesh`, optional)
           optional initial conditions
        """
        CardiacCellModel.__init__(self, params, init_conditions)

    @staticmethod
    def default_parameters():
        "Set-up and return default parameters."
        params = OrderedDict([("P_kna", 0.03),
                              ("g_K1", 5.405),
                              ("g_Kr", 0.096),
                              ("g_Ks", 0.062),
                              ("g_Na", 14.838),
                              ("g_bna", 0.00029),
                              ("g_CaL", 0.000175),
                              ("g_bca", 0.000592),
                              ("g_to", 0.294),
                              ("K_mNa", 40.0),
                              ("K_mk", 1.0),
                              ("P_NaK", 1.362),
                              ("K_NaCa", 1000.0),
                              ("K_sat", 0.1),
                              ("Km_Ca", 1.38),
                              ("Km_Nai", 87.5),
                              ("alpha", 2.5),
                              ("gamma", 0.35),
                              ("K_pCa", 0.0005),
                              ("g_pCa", 0.825),
                              ("g_pK", 0.0146),
                              ("Buf_c", 0.15),
                              ("Buf_sr", 10.0),
                              ("Ca_o", 2.0),
                              ("K_buf_c", 0.001),
                              ("K_buf_sr", 0.3),
                              ("K_up", 0.00025),
                              ("V_leak", 8e-05),
                              ("V_sr", 0.001094),
                              ("Vmax_up", 0.000425),
                              ("a_rel", 0.016464),
                              ("b_rel", 0.25),
                              ("c_rel", 0.008232),
                              ("tau_g", 2.0),
                              ("Na_o", 140.0),
                              ("Cm", 0.185),
                              ("F", 96485.3415),
                              ("R", 8314.472),
                              ("T", 310.0),
                              ("V_c", 0.016404),
                              ("stim_amplitude", 52.0),
                              ("stim_duration", 1.0),
                              ("stim_period", 1000.0),
                              ("stim_start", 10.0),
                              ("K_o", 5.4)])
        return params

    @staticmethod
    def default_initial_conditions():
        "Set-up and return default initial conditions."
        ic = OrderedDict([("V", -86.2),
                          ("Xr1", 0),
                          ("Xr2", 1),
                          ("Xs", 0),
                          ("m", 0),
                          ("h", 0.75),
                          ("j", 0.75),
                          ("d", 0),
                          ("f", 1),
                          ("fCa", 1),
                          ("s", 1),
                          ("r", 0),
                          ("g", 1),
                          ("Ca_i", 0.0002),
                          ("Ca_SR", 0.2),
                          ("Na_i", 11.6),
                          ("K_i", 138.3)])
        return ic

    def _I(self, v, s, time):
        """
        Original gotran transmembrane current dV/dt
        """
        time = time if time else Constant(0.0)

        # Assign states
        V = v
        assert(len(s) == 16)
        Xr1, Xr2, Xs, m, h, j, d, f, fCa, s, r, g, Ca_i, Ca_SR, Na_i, K_i = s

        # Assign parameters
        P_kna = self._parameters["P_kna"]
        g_K1 = self._parameters["g_K1"]
        g_Kr = self._parameters["g_Kr"]
        g_Ks = self._parameters["g_Ks"]
        g_Na = self._parameters["g_Na"]
        g_bna = self._parameters["g_bna"]
        g_CaL = self._parameters["g_CaL"]
        g_bca = self._parameters["g_bca"]
        g_to = self._parameters["g_to"]
        K_mNa = self._parameters["K_mNa"]
        K_mk = self._parameters["K_mk"]
        P_NaK = self._parameters["P_NaK"]
        K_NaCa = self._parameters["K_NaCa"]
        K_sat = self._parameters["K_sat"]
        Km_Ca = self._parameters["Km_Ca"]
        Km_Nai = self._parameters["Km_Nai"]
        alpha = self._parameters["alpha"]
        gamma = self._parameters["gamma"]
        K_pCa = self._parameters["K_pCa"]
        g_pCa = self._parameters["g_pCa"]
        g_pK = self._parameters["g_pK"]
        Ca_o = self._parameters["Ca_o"]
        Na_o = self._parameters["Na_o"]
        F = self._parameters["F"]
        R = self._parameters["R"]
        T = self._parameters["T"]
        stim_amplitude = self._parameters["stim_amplitude"]
        stim_duration = self._parameters["stim_duration"]
        stim_period = self._parameters["stim_period"]
        stim_start = self._parameters["stim_start"]
        K_o = self._parameters["K_o"]

        # Init return args
        current = [ufl.zero()]*1

        # Expressions for the Reversal potentials component
        E_Na = R*T*ufl.ln(Na_o/Na_i)/F
        E_K = R*T*ufl.ln(K_o/K_i)/F
        E_Ks = R*T*ufl.ln((K_o + Na_o*P_kna)/(P_kna*Na_i + K_i))/F
        E_Ca = 0.5*R*T*ufl.ln(Ca_o/Ca_i)/F

        # Expressions for the Inward rectifier potassium current component
        alpha_K1 = 0.1/(1.0 + 6.14421235332821e-06*ufl.exp(0.06*V - 0.06*E_K))
        beta_K1 = (0.36787944117144233*ufl.exp(0.1*V - 0.1*E_K) +\
            3.0606040200802673*ufl.exp(0.0002*V - 0.0002*E_K))/(1.0 +\
            ufl.exp(0.5*E_K - 0.5*V))
        xK1_inf = alpha_K1/(alpha_K1 + beta_K1)
        i_K1 = 0.4303314829119352*g_K1*ufl.sqrt(K_o)*(-E_K + V)*xK1_inf

        # Expressions for the Rapid time dependent potassium current component
        i_Kr = 0.4303314829119352*g_Kr*ufl.sqrt(K_o)*(-E_K + V)*Xr1*Xr2

        # Expressions for the Slow time dependent potassium current component
        i_Ks = g_Ks*ufl.elem_pow(Xs, 2.0)*(-E_Ks + V)

        # Expressions for the Fast sodium current component
        i_Na = g_Na*ufl.elem_pow(m, 3.0)*(-E_Na + V)*h*j

        # Expressions for the Sodium background current component
        i_b_Na = g_bna*(-E_Na + V)

        # Expressions for the L_type Ca current component
        i_CaL = 4.0*g_CaL*ufl.elem_pow(F, 2.0)*(-0.341*Ca_o +\
            Ca_i*ufl.exp(2.0*F*V/(R*T)))*V*d*f*fCa/(R*T*(-1.0 +\
            ufl.exp(2.0*F*V/(R*T))))

        # Expressions for the Calcium background current component
        i_b_Ca = g_bca*(-E_Ca + V)

        # Expressions for the Transient outward current component
        i_to = g_to*(-E_K + V)*r*s

        # Expressions for the Sodium potassium pump current component
        i_NaK = K_o*P_NaK*Na_i/((K_mNa + Na_i)*(K_mk + K_o)*(1.0 +\
            0.0353*ufl.exp(-F*V/(R*T)) + 0.1245*ufl.exp(-0.1*F*V/(R*T))))

        # Expressions for the Sodium calcium exchanger current component
        i_NaCa = K_NaCa*(Ca_o*ufl.elem_pow(Na_i,\
            3.0)*ufl.exp(F*gamma*V/(R*T)) - alpha*ufl.elem_pow(Na_o,\
            3.0)*Ca_i*ufl.exp(F*(-1.0 + gamma)*V/(R*T)))/((1.0 +\
            K_sat*ufl.exp(F*(-1.0 + gamma)*V/(R*T)))*(Ca_o +\
            Km_Ca)*(ufl.elem_pow(Km_Nai, 3.0) + ufl.elem_pow(Na_o, 3.0)))

        # Expressions for the Calcium pump current component
        i_p_Ca = g_pCa*Ca_i/(K_pCa + Ca_i)

        # Expressions for the Potassium pump current component
        i_p_K = g_pK*(-E_K + V)/(1.0 +\
            65.40521574193832*ufl.exp(-0.16722408026755853*V))

        # Expressions for the Membrane component
        i_Stim = ufl.conditional(ufl.And(ufl.ge(time -\
            stim_period*ufl.floor(time/stim_period), stim_start), ufl.le(time\
            - stim_period*ufl.floor(time/stim_period), stim_duration +\
            stim_start)), -stim_amplitude, 0)
        current[0] = -1.0*i_CaL - 1.0*i_K1 - 1.0*i_Kr - 1.0*i_Ks - 1.0*i_Na -\
            1.0*i_NaCa - 1.0*i_NaK - 1.0*i_Stim - 1.0*i_b_Ca - 1.0*i_b_Na -\
            1.0*i_p_Ca - 1.0*i_p_K - 1.0*i_to

        # Return results
        return current[0]

    def I(self, v, s, time=None):
        """
        Transmembrane current

           I = -dV/dt

        """
        return -self._I(v, s, time)

    def F(self, v, s, time=None):
        """
        Right hand side for ODE system
        """
        time = time if time else Constant(0.0)

        # Assign states
        V = v
        assert(len(s) == 16)
        Xr1, Xr2, Xs, m, h, j, d, f, fCa, s, r, g, Ca_i, Ca_SR, Na_i, K_i = s

        # Assign parameters
        P_kna = self._parameters["P_kna"]
        g_K1 = self._parameters["g_K1"]
        g_Kr = self._parameters["g_Kr"]
        g_Ks = self._parameters["g_Ks"]
        g_Na = self._parameters["g_Na"]
        g_bna = self._parameters["g_bna"]
        g_CaL = self._parameters["g_CaL"]
        g_bca = self._parameters["g_bca"]
        g_to = self._parameters["g_to"]
        K_mNa = self._parameters["K_mNa"]
        K_mk = self._parameters["K_mk"]
        P_NaK = self._parameters["P_NaK"]
        K_NaCa = self._parameters["K_NaCa"]
        K_sat = self._parameters["K_sat"]
        Km_Ca = self._parameters["Km_Ca"]
        Km_Nai = self._parameters["Km_Nai"]
        alpha = self._parameters["alpha"]
        gamma = self._parameters["gamma"]
        K_pCa = self._parameters["K_pCa"]
        g_pCa = self._parameters["g_pCa"]
        g_pK = self._parameters["g_pK"]
        Buf_c = self._parameters["Buf_c"]
        Buf_sr = self._parameters["Buf_sr"]
        Ca_o = self._parameters["Ca_o"]
        K_buf_c = self._parameters["K_buf_c"]
        K_buf_sr = self._parameters["K_buf_sr"]
        K_up = self._parameters["K_up"]
        V_leak = self._parameters["V_leak"]
        V_sr = self._parameters["V_sr"]
        Vmax_up = self._parameters["Vmax_up"]
        a_rel = self._parameters["a_rel"]
        b_rel = self._parameters["b_rel"]
        c_rel = self._parameters["c_rel"]
        tau_g = self._parameters["tau_g"]
        Na_o = self._parameters["Na_o"]
        Cm = self._parameters["Cm"]
        F = self._parameters["F"]
        R = self._parameters["R"]
        T = self._parameters["T"]
        V_c = self._parameters["V_c"]
        stim_amplitude = self._parameters["stim_amplitude"]
        stim_duration = self._parameters["stim_duration"]
        stim_period = self._parameters["stim_period"]
        stim_start = self._parameters["stim_start"]
        K_o = self._parameters["K_o"]

        # Init return args
        F_expressions = [ufl.zero()]*16

        # Expressions for the Reversal potentials component
        E_Na = R*T*ufl.ln(Na_o/Na_i)/F
        E_K = R*T*ufl.ln(K_o/K_i)/F
        E_Ks = R*T*ufl.ln((K_o + Na_o*P_kna)/(P_kna*Na_i + K_i))/F
        E_Ca = 0.5*R*T*ufl.ln(Ca_o/Ca_i)/F

        # Expressions for the Inward rectifier potassium current component
        alpha_K1 = 0.1/(1.0 + 6.14421235332821e-06*ufl.exp(0.06*V - 0.06*E_K))
        beta_K1 = (0.36787944117144233*ufl.exp(0.1*V - 0.1*E_K) +\
            3.0606040200802673*ufl.exp(0.0002*V - 0.0002*E_K))/(1.0 +\
            ufl.exp(0.5*E_K - 0.5*V))
        xK1_inf = alpha_K1/(alpha_K1 + beta_K1)
        i_K1 = 0.4303314829119352*g_K1*ufl.sqrt(K_o)*(-E_K + V)*xK1_inf

        # Expressions for the Rapid time dependent potassium current component
        i_Kr = 0.4303314829119352*g_Kr*ufl.sqrt(K_o)*(-E_K + V)*Xr1*Xr2

        # Expressions for the Xr1 gate component
        xr1_inf = 1.0/(1.0 +\
            0.02437284407327961*ufl.exp(-0.14285714285714285*V))
        alpha_xr1 = 450.0/(1.0 + 0.011108996538242306*ufl.exp(-0.1*V))
        beta_xr1 = 6.0/(1.0 +\
            13.581324522578193*ufl.exp(0.08695652173913043*V))
        tau_xr1 = 1.0*alpha_xr1*beta_xr1
        F_expressions[0] = (-Xr1 + xr1_inf)/tau_xr1

        # Expressions for the Xr2 gate component
        xr2_inf = 1.0/(1.0 + 39.12128399815321*ufl.exp(0.041666666666666664*V))
        alpha_xr2 = 3.0/(1.0 + 0.049787068367863944*ufl.exp(-0.05*V))
        beta_xr2 = 1.12/(1.0 + 0.049787068367863944*ufl.exp(0.05*V))
        tau_xr2 = 1.0*alpha_xr2*beta_xr2
        F_expressions[1] = (-Xr2 + xr2_inf)/tau_xr2

        # Expressions for the Slow time dependent potassium current component
        i_Ks = g_Ks*ufl.elem_pow(Xs, 2.0)*(-E_Ks + V)

        # Expressions for the Xs gate component
        xs_inf = 1.0/(1.0 + 0.6996725373751304*ufl.exp(-0.07142857142857142*V))
        alpha_xs = 1100.0/ufl.sqrt(1.0 +\
            0.18887560283756186*ufl.exp(-0.16666666666666666*V))
        beta_xs = 1.0/(1.0 + 0.049787068367863944*ufl.exp(0.05*V))
        tau_xs = 1.0*alpha_xs*beta_xs
        F_expressions[2] = (-Xs + xs_inf)/tau_xs

        # Expressions for the Fast sodium current component
        i_Na = g_Na*ufl.elem_pow(m, 3.0)*(-E_Na + V)*h*j

        # Expressions for the m gate component
        m_inf = 1.0*ufl.elem_pow(1.0 +\
            0.0018422115811651339*ufl.exp(-0.1107419712070875*V), -2.0)
        alpha_m = 1.0/(1.0 + 6.14421235332821e-06*ufl.exp(-0.2*V))
        beta_m = 0.1/(1.0 + 1096.6331584284585*ufl.exp(0.2*V)) + 0.1/(1.0 +\
            0.7788007830714049*ufl.exp(0.005*V))
        tau_m = 1.0*alpha_m*beta_m
        F_expressions[3] = (-m + m_inf)/tau_m

        # Expressions for the h gate component
        h_inf = 1.0*ufl.elem_pow(1.0 +\
            15212.593285654404*ufl.exp(0.13458950201884254*V), -2.0)
        alpha_h = ufl.conditional(ufl.lt(V, -40.0),\
            4.4312679295805147e-07*ufl.exp(-0.14705882352941177*V), 0)
        beta_h = ufl.conditional(ufl.lt(V, -40.0), 310000.0*ufl.exp(0.3485*V)\
            + 2.7*ufl.exp(0.079*V), 0.77/(0.13 +\
            0.049758141083938695*ufl.exp(-0.0900900900900901*V)))
        tau_h = 1.0/(alpha_h + beta_h)
        F_expressions[4] = (-h + h_inf)/tau_h

        # Expressions for the j gate component
        j_inf = 1.0*ufl.elem_pow(1.0 +\
            15212.593285654404*ufl.exp(0.13458950201884254*V), -2.0)
        alpha_j = ufl.conditional(ufl.lt(V, -40.0), 1.0*(37.78 +\
            V)*(-25428.0*ufl.exp(0.2444*V) -\
            6.948e-06*ufl.exp(-0.04391*V))/(1.0 +\
            50262745825.95399*ufl.exp(0.311*V)), 0)
        beta_j = ufl.conditional(ufl.lt(V, -40.0),\
            0.02424*ufl.exp(-0.01052*V)/(1.0 +\
            0.003960868339904256*ufl.exp(-0.1378*V)),\
            0.6*ufl.exp(0.057*V)/(1.0 +\
            0.040762203978366204*ufl.exp(-0.1*V)))
        tau_j = 1.0/(alpha_j + beta_j)
        F_expressions[5] = (-j + j_inf)/tau_j

        # Expressions for the Sodium background current component
        i_b_Na = g_bna*(-E_Na + V)

        # Expressions for the L_type Ca current component
        i_CaL = 4.0*g_CaL*ufl.elem_pow(F, 2.0)*(-0.341*Ca_o +\
            Ca_i*ufl.exp(2.0*F*V/(R*T)))*V*d*f*fCa/(R*T*(-1.0 +\
            ufl.exp(2.0*F*V/(R*T))))

        # Expressions for the d gate component
        d_inf = 1.0/(1.0 + 0.513417119032592*ufl.exp(-0.13333333333333333*V))
        alpha_d = 0.25 + 1.4/(1.0 +\
            0.0677244716592409*ufl.exp(-0.07692307692307693*V))
        beta_d = 1.4/(1.0 + 2.718281828459045*ufl.exp(0.2*V))
        gamma_d = 1.0/(1.0 + 12.182493960703473*ufl.exp(-0.05*V))
        tau_d = 1.0*alpha_d*beta_d + gamma_d
        F_expressions[6] = (-d + d_inf)/tau_d

        # Expressions for the f gate component
        f_inf = 1.0/(1.0 + 17.411708063327644*ufl.exp(0.14285714285714285*V))
        tau_f = 80.0 + 165.0/(1.0 + 12.182493960703473*ufl.exp(-0.1*V)) +\
            1125.0*ufl.exp(-0.004166666666666667*ufl.elem_pow(27.0 + V, 2.0))
        F_expressions[7] = (-f + f_inf)/tau_f

        # Expressions for the FCa gate component
        alpha_fCa = 1.0/(1.0 + 8.03402376701711e+27*ufl.elem_pow(Ca_i, 8.0))
        beta_fCa = 0.1/(1.0 + 0.006737946999085467*ufl.exp(10000.0*Ca_i))
        gama_fCa = 0.2/(1.0 + 0.391605626676799*ufl.exp(1250.0*Ca_i))
        fCa_inf = 0.15753424657534246 + 0.684931506849315*alpha_fCa +\
            0.684931506849315*beta_fCa + 0.684931506849315*gama_fCa
        tau_fCa = 2.0
        d_fCa = (-fCa + fCa_inf)/tau_fCa
        F_expressions[8] = ufl.conditional(ufl.And(ufl.gt(V, -60.0),\
            ufl.gt(fCa_inf, fCa)), 0, d_fCa)

        # Expressions for the Calcium background current component
        i_b_Ca = g_bca*(-E_Ca + V)

        # Expressions for the Transient outward current component
        i_to = g_to*(-E_K + V)*r*s

        # Expressions for the s gate component
        s_inf = 1.0/(1.0 + 54.598150033144236*ufl.exp(0.2*V))
        tau_s = 3.0 + 5.0/(1.0 + 0.01831563888873418*ufl.exp(0.2*V)) +\
            85.0*ufl.exp(-0.003125*ufl.elem_pow(45.0 + V, 2.0))
        F_expressions[9] = (-s + s_inf)/tau_s

        # Expressions for the r gate component
        r_inf = 1.0/(1.0 + 28.031624894526125*ufl.exp(-0.16666666666666666*V))
        tau_r = 0.8 + 9.5*ufl.exp(-0.0005555555555555556*ufl.elem_pow(40.0 +\
            V, 2.0))
        F_expressions[10] = (-r + r_inf)/tau_r

        # Expressions for the Sodium potassium pump current component
        i_NaK = K_o*P_NaK*Na_i/((K_mNa + Na_i)*(K_mk + K_o)*(1.0 +\
            0.0353*ufl.exp(-F*V/(R*T)) + 0.1245*ufl.exp(-0.1*F*V/(R*T))))

        # Expressions for the Sodium calcium exchanger current component
        i_NaCa = K_NaCa*(Ca_o*ufl.elem_pow(Na_i,\
            3.0)*ufl.exp(F*gamma*V/(R*T)) - alpha*ufl.elem_pow(Na_o,\
            3.0)*Ca_i*ufl.exp(F*(-1.0 + gamma)*V/(R*T)))/((1.0 +\
            K_sat*ufl.exp(F*(-1.0 + gamma)*V/(R*T)))*(Ca_o +\
            Km_Ca)*(ufl.elem_pow(Km_Nai, 3.0) + ufl.elem_pow(Na_o, 3.0)))

        # Expressions for the Calcium pump current component
        i_p_Ca = g_pCa*Ca_i/(K_pCa + Ca_i)

        # Expressions for the Potassium pump current component
        i_p_K = g_pK*(-E_K + V)/(1.0 +\
            65.40521574193832*ufl.exp(-0.16722408026755853*V))

        # Expressions for the Calcium dynamics component
        i_rel = (c_rel + a_rel*ufl.elem_pow(Ca_SR, 2.0)/(ufl.elem_pow(b_rel,\
            2.0) + ufl.elem_pow(Ca_SR, 2.0)))*d*g
        i_up = Vmax_up/(1.0 + ufl.elem_pow(K_up, 2.0)*ufl.elem_pow(Ca_i, -2.0))
        i_leak = V_leak*(-Ca_i + Ca_SR)
        g_inf = ufl.conditional(ufl.lt(Ca_i, 0.00035), 1.0/(1.0 +\
            5.439910241481018e+20*ufl.elem_pow(Ca_i, 6.0)), 1.0/(1.0 +\
            1.9720198874049195e+55*ufl.elem_pow(Ca_i, 16.0)))
        d_g = (-g + g_inf)/tau_g
        F_expressions[11] = ufl.conditional(ufl.And(ufl.gt(V, -60.0),\
            ufl.gt(g_inf, g)), 0, d_g)
        Ca_i_bufc = 1.0/(1.0 + Buf_c*K_buf_c*ufl.elem_pow(K_buf_c + Ca_i,\
            -2.0))
        Ca_sr_bufsr = 1.0/(1.0 + Buf_sr*K_buf_sr*ufl.elem_pow(K_buf_sr +\
            Ca_SR, -2.0))
        F_expressions[12] = (-i_up - 0.5*Cm*(1.0*i_CaL + 1.0*i_b_Ca +\
            1.0*i_p_Ca - 2.0*i_NaCa)/(F*V_c) + i_leak + i_rel)*Ca_i_bufc
        F_expressions[13] = V_c*(-i_leak - i_rel + i_up)*Ca_sr_bufsr/V_sr

        # Expressions for the Sodium dynamics component
        F_expressions[14] = 1.0*Cm*(-1.0*i_Na - 1.0*i_b_Na - 3.0*i_NaCa -\
            3.0*i_NaK)/(F*V_c)

        # Expressions for the Membrane component
        i_Stim = ufl.conditional(ufl.And(ufl.ge(time -\
            stim_period*ufl.floor(time/stim_period), stim_start), ufl.le(time\
            - stim_period*ufl.floor(time/stim_period), stim_duration +\
            stim_start)), -stim_amplitude, 0)

        # Expressions for the Potassium dynamics component
        F_expressions[15] = 1.0*Cm*(2.0*i_NaK - 1.0*i_K1 - 1.0*i_Kr -\
            1.0*i_Ks - 1.0*i_Stim - 1.0*i_p_K - 1.0*i_to)/(F*V_c)

        # Return results
        return dolfin.as_vector(F_expressions)

    def num_states(self):
        return 16

    def __str__(self):
        return 'Tentusscher_2004_mcell cardiac cell model'
